package hw3;
import java.util.ArrayList;
import java.util.Random;

import api.Direction;
import api.ShiftDescriptor;
import api.TileInfo;

import static api.Direction.*;

/**
 * This class contains the state and logic for an implementation of a
 * video game we call AlphabetSoup.  The basic underlying state is an n by n 
 * grid of tiles, represented by integer values.  A zero in a cell is considered 
 * to be "empty".  To play the game, a client calls the method <code>shift()</code>, 
 * selecting one of the four directions (LEFT, RIGHT, UP, DOWN). Each row or 
 * column is then shifted according to the rules encapsulated in the
 * associated <code>AlphabetUtil</code> object. The move is completed by
 * calling <code>setNewTile</code>, which makes a new tile appear in the grid
 * in preparation for the next move.
 * <p>
 * The game uses an instance of java.util.Random to generate new tile values
 * and to select the location for a new tile to appear.  The new values
 * are generated by the associated <code>AlphabetUtil</code>'s 
 * <code>randomNewTileValue</code> method, and the new positions are
 * generated in the <code>setNewTile</code> method of this class. 
 * <p>
 * The score in the game is the sum, over all cells, of the individual scores
 * returned by the <code>AlphabetUtil</code>'s <code>getScoreForOneTile()</code> 
 * method.
 * @author Jordan Rios
 */
public class AlphabetSoup
{
	/**
	 * Instance variable for game configuration
	 */
	private AlphabetUtil gameConfig;

	/**
	 * Instance variable for the games random number generator
	 */
	private Random gameRng;

	/**
	 * Instance variable for the games grid size
	 */
	private int[][] gameGrid;

	/**
	 * Instance variable for game score
	 */
	private int gameScore;

	/**
	 * Instance variable for the last direction called from shift
	 */
	private Direction lastDirection;

	/**
	 * Constructs a game with a grid of the given size, using a default
	 * random number generator. The initial grid is produced by the 
	 * <code>createNewGrid</code> method of the given 
	 * <code>AlphabetUtil</code> object.  
	 * @param givenSize
	 *   size of the grid for this game
	 * @param givenConfig
	 *   given instance of GameUtil   
	 */
	public AlphabetSoup(int givenSize, AlphabetUtil givenConfig)
	{
		gameConfig = givenConfig;
		gameGrid = new int[givenSize][givenSize];
		gameScore = 0;
		lastDirection = null;
		gameRng = new Random();

		// Place 2 new tiles in random cells of the grid
		gameGrid[gameRng.nextInt(givenSize)][gameRng.nextInt(givenSize)] = gameConfig.randomNewTileValue(gameRng);
		gameGrid[gameRng.nextInt(givenSize)][gameRng.nextInt(givenSize)] = gameConfig.randomNewTileValue(gameRng);
	}

	/**
	 * Constructs a game with a grid of the given size, using the given
	 * instance of <code>Random</code> for the random number generator.
	 * The initial grid is produced by the <code>createNewGrid</code> method 
	 * of the given <code>AlphabetUtil</code> object.  
	 * @param givenSize
	 *   size of the grid for this game
	 * @param givenConfig
	 *   given instance of AlphabetUtil
	 * @param givenRandom
	 *   given instance of Random   
	 */
	public AlphabetSoup(int givenSize, AlphabetUtil givenConfig, Random givenRandom)
	{
		gameConfig = givenConfig;
		gameGrid = new int[givenSize][givenSize];
		gameRng = givenRandom;
		gameScore = 0;
		lastDirection = null;

		// Place 2 new tiles in random cells of the grid
		gameGrid[gameRng.nextInt(givenSize)][gameRng.nextInt(givenSize)] = gameConfig.randomNewTileValue(gameRng);
		gameGrid[gameRng.nextInt(givenSize)][gameRng.nextInt(givenSize)] = gameConfig.randomNewTileValue(gameRng);
	}

	/**
	 * Returns the value in the cell at the given row and column.
	 * @param row
	 *   given row
	 * @param col
	 *   given column
	 * @return
	 *   value in the cell at the given row and column
	 */
	public int getCell(int row, int col)
	{
		return gameGrid[row][col];
	}

	/**
	 * Sets the value of the cell at the given row and column.
	 * <em>NOTE: This method should not be used by clients outside
	 * of a testing environment.</em>
	 * @param row
	 *   given row
	 * @param col
	 *   given col
	 * @param value
	 *   value to be set
	 */
	public void setCell(int row, int col, int value)
	{
		gameGrid[row][col] = value;
	}

	/**
	 * Returns the size of this game's grid.
	 * @return
	 *   size of the grid
	 */
	public int getSize()
	{
		return gameGrid.length;
	}

	/**
	 * Returns the current score.
	 * @return
	 *   score for this game
	 */
	public int getScore()
	{
		return gameScore;
	}

	/**
	 * Returns the direction from the most recent call to <code>shift()</code>
	 * when a corresponding call to <code>setNewTile()</code> has not yet been 
	 * made. Otherwise, the method returns null.
	 * @return
	 *   direction of current pending shift
	 */
	public Direction getLastDirection()
	{
		return lastDirection;
	}

	/**
	 * Copy a row or column from the grid into a new one-dimensional array.  
	 * There are four possible actions depending on the given direction:
	 * <ul>
	 *   <li>LEFT - the row indicated by the index <code>rowOrColumn</code> is
	 *   copied into the new array from left to right
	 *   <li>RIGHT - the row indicated by the index <code>rowOrColumn</code> is
	 *   copied into the new array in reverse (from right to left)
	 *   <li>UP - the column indicated by the index <code>rowOrColumn</code> is
	 *   copied into the new array from top to bottom
	 *   <li>DOWN - the row indicated by the index <code>rowOrColumn</code> is
	 *   copied into the new array in reverse (from bottom to top)
	 * </ul>
	 * @param rowOrColumn
	 *   index of the row or column
	 * @param dir
	 *   direction from which to begin copying
	 * @return
	 *   array containing the row or column
	 */
	public int[] getRowColumn(int rowOrColumn, Direction dir)
	{
		// array of row or column to be returned
		int[] rowColumn = new int[gameGrid[rowOrColumn].length];

		// shorthanded value for the length of the row or column
		int rcLength = rowColumn.length; 

		// if the direction of the shift is left
		if (dir == LEFT) 
		{
			// copy incoming row from game grid into rowColumn from left to right
			for (int i = 0; i < rcLength; i += 1) 
			{
				rowColumn[i] = gameGrid[rowOrColumn][i];
			}
		}
		
		// if the direction of the shift is right
		else if (dir == RIGHT) 
		{
			// copy incoming row from game grid into rowColumn from right to left
			for (int i = rcLength - 1; i >= 0; i -= 1) 
			{
				rowColumn[i] = gameGrid[rowOrColumn][rcLength - i - 1];
			}
		}
		
		// if the direction of the shift is up
		else if (dir == UP) 
		{
			// copy incoming column from game grid into rowColumn from top to bottom
			for (int i = 0; i < rcLength; i += 1) 
			{
				rowColumn[i] = gameGrid[i][rowOrColumn];
			}
		}
		
		// if the direction of the shift is down
		else if (dir == DOWN) 
		{
			// copy incoming column from game grid into rowColumn from bottom to top
			for (int i = rcLength - 1; i >= 0; i -= 1) 
			{
				rowColumn[i] = gameGrid[rcLength - i - 1][rowOrColumn];
			}
		}
		return rowColumn;
	}

	/**
	 * Updates the grid by copying the given one-dimensional array into
	 * a row or column of the grid.
	 * There are four possible actions depending on the given direction:
	 * <ul>
	 *   <li>LEFT - the given array is copied into the the row indicated by the 
	 *   index <code>rowOrColumn</code> from left to right
	 *   <li>RIGHT - the given array is copied into the the row indicated by the 
	 *   index <code>rowOrColumn</code> in reverse (from right to left)
	 *   <li>UP - the given array is copied into the column indicated by the 
	 *   index <code>rowOrColumn</code> from top to bottom
	 *   <li>DOWN - the given array is copied into the column indicated by the 
	 *   index <code>rowOrColumn</code> in reverse (from bottom to top)
	 * </ul>
	 * @param arr
	 *   the array from which to copy
	 * @param rowOrColumn
	 *   index of the row or column
	 * @param dir
	 *   direction from which to begin copying
	 */
	public void setRowColumn(int[] arr, int rowOrColumn, Direction dir)
	{
		// if the direction of the shift is left
		if (dir == LEFT) 
		{
			// the incoming array is copied into the indicated row from left to right
			for (int i = 0; i < arr.length; i += 1) 
			{
				gameGrid[rowOrColumn][i] = arr[i];
			}
		}
		
		// if the direction of the shift is right
		else if (dir == RIGHT) 
		{
			// the incoming array is copied into the indicated row from right to left
			for (int i = arr.length - 1; i >= 0; i -= 1) 
			{
				gameGrid[rowOrColumn][i] = arr[arr.length - i - 1];
			}
		}
		
		// if the direction of the shift is up
		else if (dir == UP) 
		{
			// the incoming array is copied into the indicated column from top to bottom
			for (int i = 0; i < arr.length; i += 1) 
			{
				gameGrid[i][rowOrColumn] = arr[i];
			}
		}
		
		// if the direction of the shift is down
		else if (dir == DOWN) 
		{
			// the incoming array is copied into the indicated column from bottom to top
			for (int i = arr.length - 1; i >= 0; i -= 1) 
			{
				gameGrid[i][rowOrColumn] = arr[arr.length - i - 1];
			}
		}
	}

	/**
	 * Plays one step of the game by shifting the grid in the given direction.
	 * Returns a list of <code>ShiftDescriptor</code> objects describing all 
	 * moves performed.  All <code>ShiftDescriptor</code> 
	 * objects must include a valid value for <code>getRowOrColumn()</code> and 
	 * <code>getDirection()</code>.  If no cells are actually moved, the method returns
	 * an empty list.
	 * <p>
	 * The shift of an individual row or column is performed by the 
	 * method <code>shift()</code> of the associated <code>AlphabetUtil</code>
	 * instance.  
	 * <p>
	 * This method does not update the score (that occurs in <code>setNewTile()</code>).
	 * 
	 * @param dir
	 *   direction in which to shift the grid
	 * @return
	 *   list of moved or merged tiles
	 */
	public ArrayList<ShiftDescriptor> shift(Direction dir)
	{
		// shorthand variable for row or column length
		int rcLength = gameGrid.length;
		
		// temporary array to store each row or column from getRowOrColumn to be shifted
		int[] tempArray;
		
		// possibly redundant: temporary array list for incoming ShiftDescriptors to be set and appended to the descriptors list
		ArrayList<ShiftDescriptor> tempList;
		
		// the list of lists of shift descriptors to be returned from each row or column
		ArrayList<ShiftDescriptor> descriptors = new ArrayList<>();

		// for each row or column
		for (int i = 0; i < rcLength; i += 1) 
		{
			tempList = new ArrayList<>();

			// copy row or column into a tempArray
			tempArray = getRowColumn(i, dir);
			
			// perform shift on tempArray and add all elements returned from doShift to the tempList
			tempList.addAll(gameConfig.doShift(tempArray)); 

			// for each ShiftDescriptor in the tempList: set it's direction and append it to descriptors list
			for (ShiftDescriptor description: tempList)
			{
				description.setDirection(i, dir);
				descriptors.add(description);
			}
			
			// copy temp row or column into game row or column
			setRowColumn(tempArray, i, dir); 
		}
		if (descriptors.isEmpty())
		{
			lastDirection = null;
		}
		else 
		{
			lastDirection = dir;
		}

		return descriptors;
	}

	/**
	 * Helper method for setNewTile to calculate and update the game score
	 * 
	 */
	private void calculateScore()
	{
		// add each tile value to score
		for (int row = 0; row < gameGrid.length; row += 1) 
		{
			for (int col = 0; col < gameGrid.length; col += 1)
			{
				gameScore += gameConfig.getScoreForOneTile(gameGrid[row][col]);
			}
		}
	}
	/**
	 * Generates a new tile and places its value in the grid, provided that
	 * there was a previous call to  <code>shift()</code> without a 
	 * corresponding call to <code>setNewTile</code> (in other words, 
	 * when <code>getLastDirection()</code> returns a non-null value). 
	 * In all other cases, this method does nothing and returns null.
	 * <p>
	 * The tile's value is determined by the associated
	 * <code>AlphabetUtil</code>'s <code>randomNewTileValue()</code> method.
	 * The tile's position is randomly selected from the empty cells
	 * on the side of the grid opposite the previous move's direction.
	 * <p>
	 * This method updates the total score, and the score includes the newly 
	 * generated tile.
	 * 
	 * @return
	 *   TileInfo object containing the new tile's position and value, or null
	 *   if no new tile is added to the grid
	 */
	public TileInfo setNewTile()
	{
		int newValue;
		int rcLength = gameGrid.length;
		int firstRowOrColumn = 0;
		int lastRowOrColumn = rcLength - 1;
		int randIndex;
		int[] tempArray;
		
		// Array list of empty indicies
		ArrayList<Integer> emptyIndicies = new ArrayList<>(); 

		if (lastDirection == LEFT)
		{
			// grab last column
			tempArray = getRowColumn(lastRowOrColumn, UP);  

			// add the index of any empty cells in temp array into array list
			for (int i = 0; i < rcLength; i += 1) 
			{
				if (tempArray[i] == 0)
				{
					emptyIndicies.add(i);
				}
			}

			// do nothing if there are no empty tiles
			if (emptyIndicies.size() == 0)
			{
				return null;
			}

			// pick a random index from known empty cells
			randIndex = emptyIndicies.get(gameRng.nextInt(emptyIndicies.size())); 

			// generate a new random tile
			newValue = gameConfig.randomNewTileValue(gameRng);

			// assign new tile to random empty index
			gameGrid[randIndex][lastRowOrColumn] = newValue;

			calculateScore();

			return new TileInfo(randIndex, lastRowOrColumn, newValue);
		}
		else if (lastDirection == RIGHT)
		{
			// grab first column
			tempArray = getRowColumn(firstRowOrColumn, UP);  

			// add the index of any empty cells in temp array into array list
			for (int i = 0; i < rcLength; i += 1) 
			{
				if (tempArray[i] == 0)
				{
					emptyIndicies.add(i);
				}
			}

			// do nothing if there are no empty cells
			if (emptyIndicies.size() == 0)
			{
				return null;
			}

			// pick a random index from known empty cells
			randIndex = emptyIndicies.get(gameRng.nextInt(emptyIndicies.size())); 

			// generate a new random tile
			newValue = gameConfig.randomNewTileValue(gameRng);

			// assign new tile to random empty index
			gameGrid[randIndex][firstRowOrColumn] = newValue;

			calculateScore();

			return new TileInfo(randIndex, firstRowOrColumn, newValue);
		}
		else if (lastDirection == UP)
		{
			// grab last row
			tempArray = getRowColumn(lastRowOrColumn, LEFT);  

			// add the index of any empty cells in temp array into array list
			for (int i = 0; i < rcLength; i += 1) 
			{
				if (tempArray[i] == 0)
				{
					emptyIndicies.add(i);
				}
			}

			// do nothing if there are no empty cells
			if (emptyIndicies.size() == 0)
			{
				return null;
			}

			// pick a random index from known empty cells
			randIndex = emptyIndicies.get(gameRng.nextInt(emptyIndicies.size())); 

			// generate a new random tile
			newValue = gameConfig.randomNewTileValue(gameRng);

			// assign new tile to random empty index
			gameGrid[lastRowOrColumn][randIndex] = newValue;

			calculateScore();

			return new TileInfo(lastRowOrColumn, randIndex, newValue);
		}
		else if (lastDirection == DOWN)
		{
			// grab first row
			tempArray = getRowColumn(firstRowOrColumn, LEFT);  

			// add the index of any empty cells in temp array into array list
			for (int i = 0; i < rcLength; i += 1) 
			{
				if (tempArray[i] == 0)
				{
					emptyIndicies.add(i);
				}
			}

			// do nothing if there are no empty cells
			if (emptyIndicies.size() == 0)
			{
				return null;
			}

			// pick a random index from known empty cells
			randIndex = emptyIndicies.get(gameRng.nextInt(emptyIndicies.size())); 

			// generate a new random tile
			newValue = gameConfig.randomNewTileValue(gameRng);

			// assign new tile to random empty index
			gameGrid[firstRowOrColumn][randIndex] = newValue;

			calculateScore();

			return new TileInfo(firstRowOrColumn, randIndex, newValue);
		}
		else 
		{
			return null;
		}
	}
}











